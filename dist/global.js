(()=>{var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};(()=>{"use strict";e.r(t),e.d(t,{Eventful:()=>o,emits:()=>s,version:()=>a});var n=function(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)},r=function(e,t,n,r,o){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!o)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?o.call(e,n):o?o.value=n:t.set(e,n),n};function o(e=Object){var t,o;class s extends e{constructor(){super(...arguments),this[o]=i,t.set(this,null)}on(e,o,i){let s=n(this,t,"f");if("function"!=typeof o)throw new Error("Expected a function in callback argument of Eventful#on.");s||(s=r(this,t,new Map,"f"));let a=s.get(e);a||s.set(e,a=[]),a.push([o,i])}off(e,o,i){const s=n(this,t,"f");if(!s)return;const a=s.get(e);if(!a)return;const l=a.findIndex((e=>e[0]===o&&e[1]===i));-1!==l&&(a.splice(l,1),0===a.length&&s.delete(e),0===s.size&&r(this,t,null,"f"))}emit(e,r){const o=n(this,t,"f");if(!o)return;const i=o.get(e);if(!i)return;let s,a,l;for(let e=0,t=i.length;e<t;e+=1)s=i[e],a=s[0],l=s[1],a.call(l,r)}}return t=new WeakMap,o=i,s.prototype[i]=i,s}const i=Symbol("isEventful");function s(e){return(t,n,r)=>function(e,t,n,r){if(!(e instanceof o))throw new TypeError("The @emits decorator is only for use on properties of classes that extend from Eventful.");const i=Symbol("@emits: "+t);let s=!1;n||(s=!0,n=Object.getOwnPropertyDescriptor(e,t));let a,l,c,f,d=!1;if(n)if(n.get||n.set){if(d=!0,a=n.get,l=n.set,!l)return void console.warn('The `@emits` decorator was used on an accessor named "'+t+"\" which did not have a setter. This means an event will never be emitted because the value can not be set. In this case the decorator doesn't do anything.");delete n.get,delete n.set}else{if(c=n.value,f=n.writable,!f)return void console.warn('The `@emits` decorator was used on a property named "'+t+'" that is not writable. An event can not be emitted because the property can not be modified. In this case the decorator does not do anything.');delete n.value,delete n.writable}let u=!1;function h(){this.emit(r,t)}if(n={...n,configurable:!0,...d?a?{get(){return a.call(this)}}:{}:{get(){return u?this[i]:(u=!0,this[i]=c)}},...d?{set(e){l.call(this,e),Promise.resolve().then(h.bind(this))}}:{set(e){u||(u=!0),this[i]=e,Promise.resolve().then(h.bind(this))}}},!s)return n;Object.defineProperty(e,t,n)}(t,n,null!=r?r:void 0,e)}Object.defineProperty(o,Symbol.hasInstance,{value:e=>!!e&&!!e[i]});const a="0.2.5"})();var n=eventful="undefined"==typeof eventful?{}:eventful;for(var r in t)n[r]=t[r];t.__esModule&&Object.defineProperty(n,"__esModule",{value:!0})})();
//# sourceMappingURL=global.js.map