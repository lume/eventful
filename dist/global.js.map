{"version":3,"file":"global.js","mappings":"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","sources":["webpack://eventful/webpack/bootstrap","webpack://eventful/webpack/runtime/define property getters","webpack://eventful/webpack/runtime/hasOwnProperty shorthand","webpack://eventful/webpack/runtime/make namespace object","webpack://eventful/./src/Eventful.ts","webpack://eventful/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type {Constructor} from 'lowclass'\n\n// TODO, make strongly typed event args. Combine with stuff in Events.ts (or similar).\n\n// TODO, Make sure emit will not attempt to call event handlers removed\n// during emit (in place modification of listeners array during emit iteration\n// will try to access undefined after the end of the array). Possibly use\n// for..of with a Set instead, otherwise modify the iteration index manually.\n\n// TODO, an option to defer events, and batch them (so that 3 of the\n// same event and payload triggers only one event instead of three)\n\n/**\n * @mixin\n * @class Eventful - An instance of Eventful emits events that code can\n * subscribe to with callbacks. Events may optionally pass a payload to the\n * callbacks.\n *\n * Callbacks can be associated with contexts to be called with (called with\n * Function.prototype.call), which offers more performance than similar\n * patterns that don't allow contexts to be specified (in those cases the user\n * has to create new arrow functions or function clones with\n * Function.prototype.bind, which is heavier).\n *\n * For example, suppose some object `rectangle` emits events named \"resize\".\n * One can react to those events by subscribing to them with a callback:\n *\n * ```js\n * const onResize = size => {\n *   // whenever `object` emits a \"resize\" event, the event passes a payload\n *   // containing the new size of `object`:\n *   console.log(size) // for example, {x: 123, y: 123}\n * }\n *\n * rectangle.on(\"resize\", onResize)\n * ```\n *\n * To stop reacting to the \"resize\" event later, we can unsubscribe the\n * callback from the \"resize\" events:\n *\n * ```js\n * rectangle.off(\"resize\", onResize)\n * ```\n */\nexport function Eventful<T extends Constructor>(Base: T = Object as any) {\n\tclass Eventful extends Base {\n\t\t// @ts-ignore to avoid \"is using private name\" errors in consumer code.\n\t\t[isEventful as any] = isEventful as any\n\n\t\t/**\n\t\t * @method on - Register a `callback` to be executed any\n\t\t * time an event with name `eventName` is triggered by an instance of\n\t\t * Eventful. If a `context` is passed to `.on()`, the `callback` is\n\t\t * associated with both `eventName` and `context`. Make sure to also\n\t\t * call `.off()` with the same `context` or else the callabck\n\t\t * associated with that `context` will not be removed.\n\t\t *\n\t\t * @param {string} eventName - The name of the event to listen for.\n\t\t * @param {Function} callback - A callback that will be called anytime the event named `eventName` happens. The callback may receive certain arguments depending on the event that the callback is subscribed to.\n\t\t * @param {any} context - An optional context to call the callback with. Passing no context is the same as subscribing `callback` for a `context` of `undefined`.\n\t\t */\n\t\ton(eventName: string, callback: Function, context?: any) {\n\t\t\tlet eventMap = this.#eventMap\n\n\t\t\t// @prod-prune\n\t\t\tif (typeof callback !== 'function') throw new Error('Expected a function in callback argument of Eventful#on.')\n\n\t\t\tif (!eventMap) eventMap = this.#eventMap = new Map()\n\n\t\t\tlet callbacks = eventMap.get(eventName)\n\n\t\t\tif (!callbacks) eventMap.set(eventName, (callbacks = []))\n\n\t\t\tcallbacks.push([callback, context])\n\t\t}\n\n\t\t/**\n\t\t * @method off - Stop a `callback` from being fired for event named `eventName`. If\n\t\t * the callback was previously registered along with a `context` in\n\t\t * `.on()`, be sure to pass the `context` to `.off()` as well.\n\t\t *\n\t\t * @param {string} eventName - The name of the event to unsubscribe `callback` from.\n\t\t * @param {Function} callback - The callback that will be no longer be executed when the event happens.\n\t\t * @param {any} context - A context associated with `callback`. Not passing a `context` arg is equivalent to unsubscribing the `callback` for `context` of `undefined`.\n\t\t */\n\t\toff(eventName: string, callback?: Function, context?: any) {\n\t\t\tconst eventMap = this.#eventMap\n\n\t\t\tif (!eventMap) return\n\n\t\t\tconst callbacks = eventMap.get(eventName)\n\n\t\t\tif (!callbacks) return\n\n\t\t\tconst index = callbacks.findIndex(tuple => tuple[0] === callback && tuple[1] === context)\n\n\t\t\tif (index === -1) return\n\n\t\t\tcallbacks.splice(index, 1)\n\n\t\t\tif (callbacks.length === 0) eventMap.delete(eventName)\n\n\t\t\tif (eventMap.size === 0) this.#eventMap = null\n\t\t}\n\n\t\t/**\n\t\t * @method emit - Cause the event with name `eventName` to be emitted\n\t\t * (i.e. cause the event to happen). Any callbacks subscribed to the\n\t\t * event will be executed and passed the arguments that passed into the\n\t\t * emit call.\n\t\t *\n\t\t * For example, inside a Rectangle class we might see\n\t\t *\n\t\t * ```js\n\t\t * this.emit(\"resize\", {x, y})\n\t\t * ```\n\t\t *\n\t\t * @param {string} eventName - The name of the event to emit.\n\t\t * @param {data} any - The data that is passed to each callback subscribed to the event.\n\t\t */\n\t\temit(eventName: string, data?: any) {\n\t\t\tconst eventMap = this.#eventMap\n\n\t\t\tif (!eventMap) return\n\n\t\t\tconst callbacks = eventMap.get(eventName)\n\n\t\t\tif (!callbacks) return\n\n\t\t\tlet tuple: (typeof callbacks)[0]\n\t\t\tlet callback: (typeof callbacks)[0][0]\n\t\t\tlet context: (typeof callbacks)[0][1]\n\n\t\t\tfor (let i = 0, len = callbacks.length; i < len; i += 1) {\n\t\t\t\ttuple = callbacks[i]\n\t\t\t\tcallback = tuple[0]\n\t\t\t\tcontext = tuple[1]\n\t\t\t\tcallback.call(context, data)\n\t\t\t}\n\t\t}\n\n\t\t#eventMap: Map<string, Array<[Function, any]>> | null = null\n\t}\n\n\tEventful.prototype[isEventful] = isEventful\n\n\treturn Eventful\n}\n\nconst isEventful = Symbol('isEventful')\n\nObject.defineProperty(Eventful, Symbol.hasInstance, {\n\tvalue(obj: any): boolean {\n\t\tif (!obj) return false\n\t\tif (obj[isEventful]) return true\n\t\treturn false\n\t},\n})\n\n/**\n * @decorator\n * @function emits - This is a decorator that when used on a property in a\n * class definition, causes setting of that property to emit the specified\n * event, with the event payload being the property value. This decorator must\n * be used in a class that extends from Eventful, otherwise an error is thrown.\n *\n * @example\n * class Foo {\n *   @emits('propchange') foo = 123\n * }\n * const f = new Foo\n * f.on('propchange', value => console.log('value: ', value))\n * f.foo = 456 // logs \"value: 456\"\n */\nexport function emits(eventName: string): any {\n\treturn (prototype: any, propName: string, descriptor?: PropertyDescriptor) => {\n\t\treturn _emits(prototype, propName, descriptor ?? undefined, eventName)\n\t}\n}\n\nfunction _emits(prototype: any, propName: string, descriptor: PropertyDescriptor | undefined, eventName: string): any {\n\tif (!(prototype instanceof Eventful))\n\t\tthrow new TypeError('The @emits decorator is only for use on properties of classes that extend from Eventful.')\n\n\tconst vName = Symbol('@emits: ' + propName)\n\n\t// property decorators are not passed a descriptor (unlike decorators on accessors or methods)\n\tlet calledAsPropertyDecorator = false\n\n\tif (!descriptor) {\n\t\tcalledAsPropertyDecorator = true\n\t\tdescriptor = Object.getOwnPropertyDescriptor(prototype, propName)\n\t}\n\n\tlet hasOriginalAccessor = false\n\tlet originalGet: (() => any) | undefined\n\tlet originalSet: ((v: any) => void) | undefined\n\tlet initialValue: any\n\tlet writable: boolean | undefined\n\n\tif (descriptor) {\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\thasOriginalAccessor = true\n\t\t\toriginalGet = descriptor.get\n\t\t\toriginalSet = descriptor.set\n\n\t\t\t// reactivity requires both\n\t\t\tif (!originalSet) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The `@emits` decorator was used on an accessor named \"' +\n\t\t\t\t\t\tpropName +\n\t\t\t\t\t\t'\" which did not have a setter. This means an event will never be emitted because the value can not be set. In this case the decorator doesn\\'t do anything.',\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.get\n\t\t\tdelete descriptor.set\n\t\t} else {\n\t\t\tinitialValue = descriptor.value\n\t\t\twritable = descriptor.writable\n\n\t\t\t// if it isn't writable, we don't need to make a reactive variable because\n\t\t\t// the value won't change\n\t\t\tif (!writable) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The `@emits` decorator was used on a property named \"' +\n\t\t\t\t\t\tpropName +\n\t\t\t\t\t\t'\" that is not writable. An event can not be emitted because the property can not be modified. In this case the decorator does not do anything.',\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.value\n\t\t\tdelete descriptor.writable\n\t\t}\n\t}\n\n\tlet initialValueIsSet = false\n\tfunction emitEvent(this: EventfulInstance) {\n\t\tthis.emit(eventName, propName)\n\t}\n\n\tdescriptor = {\n\t\t...descriptor,\n\t\tconfigurable: true,\n\t\t...(hasOriginalAccessor\n\t\t\t? originalGet\n\t\t\t\t? {\n\t\t\t\t\t\tget(): any {\n\t\t\t\t\t\t\treturn originalGet!.call(this)\n\t\t\t\t\t\t},\n\t\t\t\t  }\n\t\t\t\t: {}\n\t\t\t: {\n\t\t\t\t\tget(): any {\n\t\t\t\t\t\tif (!initialValueIsSet) {\n\t\t\t\t\t\t\tinitialValueIsSet = true\n\t\t\t\t\t\t\treturn ((this as any)[vName] = initialValue)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (this as any)[vName]\n\t\t\t\t\t},\n\t\t\t  }),\n\t\t...(hasOriginalAccessor\n\t\t\t? {\n\t\t\t\t\tset(newValue: any) {\n\t\t\t\t\t\toriginalSet!.call(this, newValue)\n\n\t\t\t\t\t\t// TODO should we defer the event, or not? Perhaps provide an option, and defer by default.\n\t\t\t\t\t\tPromise.resolve().then(emitEvent.bind(this as EventfulInstance))\n\t\t\t\t\t\t// emitEvent.call(this as Eventful)\n\t\t\t\t\t},\n\t\t\t  }\n\t\t\t: {\n\t\t\t\t\tset(newValue: any) {\n\t\t\t\t\t\tif (!initialValueIsSet) initialValueIsSet = true\n\t\t\t\t\t\t;(this as any)[vName] = newValue\n\t\t\t\t\t\tPromise.resolve().then(emitEvent.bind(this as EventfulInstance))\n\t\t\t\t\t},\n\t\t\t  }),\n\t}\n\n\t// If a decorator is called on a property, then returning a descriptor does\n\t// nothing, so we need to set the descriptor manually.\n\tif (calledAsPropertyDecorator) Object.defineProperty(prototype, propName, descriptor)\n\t// If a decorator is called on an accessor or method, then we must return a\n\t// descriptor in order to modify it, and doing it manually won't work.\n\telse return descriptor\n\t// Weird, huh?\n\t// This will all change with updates to the ES decorators proposal, https://github.com/tc39/proposal-decorators\n}\n\ntype EventfulInstance = InstanceType<ReturnType<typeof Eventful>>\n","export * from './Eventful.js'\n\nexport const version = '0.2.5'\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Eventful","Base","isEventful","on","eventName","callback","context","eventMap","this","Error","Map","callbacks","set","push","off","index","findIndex","tuple","splice","length","delete","size","emit","data","i","len","emits","propName","descriptor","TypeError","vName","calledAsPropertyDecorator","getOwnPropertyDescriptor","originalGet","originalSet","initialValue","writable","hasOriginalAccessor","console","warn","initialValueIsSet","emitEvent","configurable","newValue","Promise","resolve","then","bind","_emits","undefined","hasInstance","version"],"sourceRoot":""}